# Вопросы на интервью Frontend-разработчика

## Вопросы по JavaScript, TypeScript, Angular, Frontend'у и Backend'у <br/>

## 1. Сервер: основные status code браузера<br/>

## 1xx: Informational (информационные)</br>
100 Continue («продолжай»)</br>
101 Switching Protocols («переключение протоколов»)</br>
102 Processing («идёт обработка»)</br>
103 Early Hints («ранняя метаинформация»)</br>

## 2xx: Success (успешно)</br>
200 OK («хорошо»);</br>
201 Created («создано»);</br>
202 Accepted («принято»);</br>
203 Non-Authoritative Information («информация не авторитетна»);</br>
204 No Content («нет содержимого»);</br>
205 Reset Content («сбросить содержимое»);</br>
## 3xx: Redirection (перенаправление)</br>
300 Multiple Choices («множество выборов»)</br>
301 Moved Permanently («перемещено навсегда»)</br>
302 Moved Temporarily («перемещено временно»)</br>
302 Found («найдено»)</br>
303 See Other («смотреть другое»;</br>

## 4xx: Client Error (ошибка клиента)</br>
400 Bad Request («неправильный, некорректный запрос»)</br>
401 Unauthorized («не авторизован (не представился)»)</br>
403 Forbidden («запрещено (не уполномочен)»)</br>
404 Not Found («не найдено»)</br>
406 Not Acceptable («неприемлемо»)</br>
407 Proxy Authentication Required («необходима аутентификация прокси»)</br>
408 Request Timeout («истекло время ожидания»)</br>
409 Conflict («конфликт»)</br>
410 Gone («удалён»)</br>

## 5xx: Server Error (ошибка сервера)</br>
500 Internal Server Error («внутренняя ошибка сервера»)</br>
502 Bad Gateway («плохой, ошибочный шлюз»)</br>
503 Service Unavailable («сервис недоступен»)</br>
504 Gateway Timeout («шлюз не отвечает»)</br>
505 HTTP Version Not Supported («версия HTTP не поддерживается»)</br>
511 Network Authentication Required («требуется сетевая аутентификация»)</br>
520 Unknown Error («неизвестная ошибка»)</br>
521 Web Server Is Down («веб-сервер не работает»)</br>
524 A Timeout Occurred («время ожидания истекло»)</br>
526 Invalid SSL Certificate («недействительный сертификат SSL»)</br>


## 2. RxJS: Observable, Subject, BehaviorSubject, ReplaySubject, AsyncSubject
RxJS - это библиотека для составления асинхронных программ и программ, основанных на событиях, с использованием наблюдаемых последовательностей. Он предоставляет один основной тип, Observable, вспомогательные типы (Observer, Schedulers, Subjects).

ReactiveX сочетает шаблон наблюдателя с шаблоном итератора и функциональное программирование с коллекциями, чтобы удовлетворить потребность в идеальном способе управления последовательностями событий.

Основными концепциями в RxJS, которые решают асинхронное управление событиями, являются:

Observable: представляет идею вызываемой коллекции будущих значений или событий. </br>
Obser: это набор обратных вызовов, который знает, как прослушивать значения, передаваемые Observable. </br>
Subcribe: представляет выполнение наблюдаемого объекта, в первую очередь полезна для отмены выполнения.
Operators: это чистые функции, которые позволяют использовать функциональный стиль программирования для работы с коллекциями с помощью таких операций, как map, filter, concat, reduce и т.д.
Subject: эквивалентен отправителю события и является единственным способом многоадресной передачи значения или события нескольким наблюдателям.
Shedulers: это централизованные диспетчеры для управления параллелизмом, позволяющие нам координировать, когда вычисления выполняются, например, в setTimeout или requestAnimationFrame или других.

Обычная регистрация событий click через обычный JavaScript:

```js
document.addEventListener('click', () => console.log('Clicked!'));
```

Используя RxJS, вы вместо этого создаете observable:
```js

import { fromEvent } from 'rxjs';

fromEvent(document, 'click').subscribe(() => console.log('Clicked!'));
```

### Observable

Пример. Ниже приведен наблюдаемый параметр, который немедленно (синхронно) вводит значения 1, 2, 3 при подписке, а значение 4 - по истечении одной секунды с момента вызова subscribe, а затем завершает:

```js
import { Observable } from 'rxjs';

const observable = new Observable((subscriber) => {
  subscriber.next(1);
  subscriber.next(2);
  subscriber.next(3);
  setTimeout(() => {
    subscriber.next(4);
    subscriber.complete();
  }, 1000);
});
```
Чтобы увидеть результат работы, необходимо подписаться на Observable:

```js
import { Observable } from 'rxjs';

const observable = new Observable((subscriber) => {
  subscriber.next(1);
  subscriber.next(2);
  subscriber.next(3);
  setTimeout(() => {
    subscriber.next(4);
    subscriber.complete();
  }, 1000);
});

console.log('just before subscribe');
observable.subscribe({
  next(x) {
    console.log('got value ' + x);
  },
  error(err) {
    console.error('something wrong occurred: ' + err);
  },
  complete() {
    console.log('done');
  },
});
console.log('just after subscribe');
```

### Subject
Subject - это особый тип Observable, который позволяет многоадресно передавать значения многим наблюдателям. В то время как обычные наблюдаемые объекты являются одноадресными (каждый подписанный наблюдатель владеет независимым выполнением наблюдаемого объекта), объекты являются многоадресными.

Объект подобен наблюдаемому, но может осуществлять многоадресную передачу многим наблюдателям. Субъекты подобны Eventemitter: они ведут реестр многих слушателей.

```js
import { Subject } from 'rxjs';

const subject = new Subject<number>();

subject.subscribe({
  next: (v) => console.log(`observerA: ${v}`),
});
subject.subscribe({
  next: (v) => console.log(`observerB: ${v}`),
});

subject.next(1);
subject.next(2);

// Logs:
// observerA: 1
// observerB: 1
// observerA: 2
// observerB: 2
```


## 3. Микрофронтенд </br>
<b>Микрофронтенд</b> – это определенная структура архитектуры кода для фронтенд приложений.<br/>
<b>Микросервисная архитектура</b> — вариант сервис-ориентированной архитектуры программного обеспечения, направленный на взаимодействие насколько это возможно небольших, слабо связанных и легко изменяемых модулей — микросервисов, получивший распространение в середине 2010-х годов в связи с развитием практик гибкой разработки и DevOps. 

Сама идея не нова и пришла из мира бэкенда — речь о микросервисной архитектуре. Суть та же: у нас есть большое приложение, которое нужно продолжать поддерживать и разрабатывать. Над этим трудятся несколько команд, каждая из которых занимается своей частью. В логике монолитного бэкенда разрабатывать свою часть без риска затронуть функциональность другой части приложения непросто. Поэтому бэкенд разделяет приложение на микросервисы и разрабатывает их изолированно, но при этом так, чтобы они продолжали взаимодействовать между собой.

Давайте отметим несколько вещей:

- Каждый микрофронтенд может быть построен с использованием различных технологий.

- За каждый микрофронтенд может отвечать отдельная команда.

- Каждый микрофронтенд может отвечать за один микросервис.


<i>Различные практики, при помощи которых реализуется микро-фронтендовая архитектура:</i>

Единый мета-фреймворк для SPA (одностраничных приложений) комбинирует на одной странице сразу несколько приложений без необходимости обновлять страницу; таковы, в частности, React, Vue, Angular, т.д.

Множество одностраничных приложений находятся по разным URL. Для приложений с разделяемой функциональностью нужно использовать компоненты NPM или Bower.

Обособление микро-приложений в Iframes при помощи Windows. API для отправки сообщений и библиотеки нужны для координации. IFrames разделяют API, предоставляемые их родительским окном.

Различные модули должны обмениваться информацией через разделяемую шину событий. Каждый модуль работает с собственным фреймворком, когда обрабатывает входящие и исходящие события.

Микрофронтенды имеют смысл, если:
1. У вас большое приложение.
2. Несколько команд разработки.
3. Вы все чаще сталкиваетесь с проблемами при выкате обновлений приложения.

Для остальных проектов микрофронтенды будут избыточны.

Ограничения микрофронтендов:

1. Остается проблема общих ресурсов. Полноценная изоляция, как в случае с микросервисной архитектурой в бэкенде, пока невозможна.
2. Требуется прослойка для оркестрации приложения, которая может вносить свой оверхэд.

Источники: 
- https://tproger.ru/articles/mikrofrontendy-zachem-nuzhny-i-kak-k-nim-prijti/
- https://habr.com/ru/post/581012/
- https://habr.com/ru/post/661079/


## 4. Асинхронный JavaScript: Promise, Promise.all, Promise.race, Promise.any</br>
<b>Promise</b> – это специальный объект, который содержит своё состояние. Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).

Способ использования, в общих чертах, такой:

Код, которому надо сделать что-то асинхронно, создаёт объект <code>promise</code> и возвращает его.
Внешний код, получив <code>promise</code>, навешивает на него обработчики.
По завершении процесса асинхронный код переводит <code>promise</code> в состояние <code>fulfilled</code> (с результатом) или <code>rejected</code> (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде.

Синтаксис Promise
```js
const promise1 = new Promise((resolve, reject) => {
    fetch('https://jsonplaceholder.typicode.com/todos/1') # обращение к серверу
        .then(response => response.json()) 
        .then(json => resolve(json))
        .catch((err) => reject(err))
})
```
Пример с использованием Timeout
```js
const promise2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve("Promise2 status is OK!!!")
    }, 200)
})
const promise3 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Promise3 status is OK!!!"), 1000)
})
```

Возвращает успешный (resolve) промис, если все промисы выполнились успешно, иначае возращается неуспешный промис (reject)
```js
Promise.all([promise1, promise2, promise3])
    .then(() => console.log("ok!!!!"))
    .catch((err) => console.log(err))
```

Функция race([...arrayPromises]) возвращаеся промис, который выполнился быстрее всех из переданных в массив

```js
Promise.race([promise1, promise2, promise3])
    .then(r => console.log(r))
    .catch((err) => console.log(err))

```

Функция any([...arrayPromises]) возвращает промис, который выполнился быстрее всех и одновременно является успешным
```js
const slow = new Promise(resolve => setTimeout(() => resolve(1), 6000))
const fast = new Promise(resolve => setTimeout(() => resolve(2), 3000))
const theFastest = new Promise((resolve, reject) =>
    setTimeout(() => reject('Some error'), 1000))

Promise.any([slow, fast, theFastest])
    .then(() => console.log("OK"))
    .catch(() => console.log("Some error"))
```
## Основы Angular: компоненты (жизненный цикл), директивы, пайпы, сервисы, модули 

Компонент (Angular component) - обособленная часть функционала со своей логикой, HTML-шаблоном и CSS-стилями.

Класс становится Angular компонентом, если его объявлению предшествует декоратор <code>@Component()</code> с объектом конфигурации:

```ts
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
```

### Жизненный цикл компонентов в Angular
Экземпляр компонента имеет жизненный цикл, который начинается, когда Angular создает экземпляр класса компонента и отображает представление компонента вместе с его дочерними представлениями. Жизненный цикл продолжается с обнаружением изменений, поскольку Angular проверяет, когда изменяются свойства, привязанные к данным, и обновляет как представление, так и экземпляр компонента по мере необходимости. Жизненный цикл заканчивается, когда Angular уничтожает экземпляр компонента и удаляет его отрисованный шаблон из DOM. Директивы имеют аналогичный жизненный цикл, поскольку Angular создает, обновляет и уничтожает экземпляры в процессе выполнения.

Ваше приложение может использовать методы привязки жизненного цикла для подключения к ключевым событиям в жизненном цикле компонента или директивы для инициализации новых экземпляров, инициирования обнаружения изменений при необходимости, реагирования на обновления во время обнаружения изменений и очистки перед удалением экземпляров.

Все методы жизненного цикла приведены ниже:

<strong>ngOnChanges()</strong>: вызывается до метода ngOnInit() при начальной установке свойств, которые связаны механизмом привязки, а также при любой их переустановке или изменении их значений. Данный метод в качестве параметра принимает объект класса SimpleChanges, который содержит предыдущие и текущие значения свойства.

<strong>ngOnInit()</strong>: вызывается один раз после установки свойств компонента, которые участвуют в привязке. Выполняет инициализацию компонента

<strong>ngDoCheck()</strong>: вызывается при каждой проверке изменений свойств компонента сразу после методов ngOnChanges и ngOnInit

<strong>ngAfterContentInit()</strong>: вызывается один раз после метода ngDoCheck() после вставки содержимого в представление компонента кода html

<strong>ngAfterContentChecked()</strong>: вызывается фреймворком Angular при проверке изменений содержимого, которое добавляется в представление компонента. Вызывается после метода ngAfterContentInit() и после каждого последующего вызова метода ngDoCheck().

<strong>ngAfterViewInit()</strong>: вызывается фреймворком Angular после инициализации представления компонента, а также представлений дочерних компонентов. Вызывается только один раз сразу после первого вызова метода ngAfterContentChecked()

<strong>ngAfterViewChecked()</strong>: вызывается фреймворком Angular после проверки на изменения в представлении компонента, а также проверки представлений дочерних компонентов. Вызывается после первого вызова метода ngAfterViewInit() и после каждого последующего вызова ngAfterContentChecked()

<strong>ngOnDestroy()</strong>: вызывается перед тем, как фреймворк Angular удалит компонент.

### Директивы (Directives)

Angular директивы используются для манипулированием поведения DOM-дерева.
Выделяют три типа директив:

- С собственным шаблоном, или по-другому компоненты (компоненты являются директивами);
- Структурные, которые изменяют структуру DOM-дерева;
- Атрибуты, которые изменяют внешний вид или поведение по умолчанию элемента DOM-дерева.

Несмотря на существующую классификацию, иногда бывают трудно однозначно определить принадлежность к группе, поскольку одна директива может совмещать в себе функционал сразу двух групп.

По умолчанию в Angular предусмотрен ряд встроенных директив. Рассмотрим самые популярные из них.

К встроенным структурным директивам относятся: <code>*ngIf</code>, <code>*ngFor</code>, <code>*ngSwitch</code> и др. Все Angular директивы этой группы предваряются символом *.

- <code>*ngIf</code> добавляет или удаляет элемент из DOM-дерева в зависимости от истинности переданного выражения (true - добавление, false - удаление).

```ts
<div *ngIf="true">This will be added to the DOM</div>
<div *ngIf="false">This will be removed from the DOM</div>
```

- <code>*ngFor</code> используется для визуализации массива данных. Директива применяется к блоку HTML-кода, определяющего, как должны отображаться данные элемента массива. Далее Angular использует этот HTML как шаблон для всех последующих элементов в массиве.

- <code>*ngSwitch</code> эмулирует работу оператора switch применительно к шаблонам.
Angular директивы <code>*ngSwitchCase</code> и <code>*ngSwitchDefault</code> отображают указанный шаблон в зависимости от значения переданной ngSwitch переменной или шаблон по умолчанию, если ни один из описанных случаев не соответствует реальному значению.

### Пайпы (Pipes)
Angular pipe, или просто фильтр, нужен для преобразования данных прямо в HTML-шаблоне. Например, отображение даты и времени в желаемом формате или задание формата вывода числового значения.

В Angular имеется ряд встроенных фильтров, но также предусмотрена возможность создания собственных.

Рассмотрим пример использования кастомного пайпа

```ts
import { Pipe, PipeTransform } from '@angular/core';
import { IMissionRockets } from "../models/IMissionRockets";

@Pipe({
  name: 'filterIsSuccessLaunch'
})
export class SuccessLaunchPipe implements PipeTransform {
  transform(mission: IMissionRockets[], IsSuccess: boolean): IMissionRockets[] {
    if (!IsSuccess) return mission.filter(m => !m.cores[0].landing_success)
    else {
      return mission.filter(m => m.cores[0].landing_success && m.cores[0].landing_success !== null);
    }
  }

}

```

### Сервисы (Services)
Angular сервис - это обычный класс, используемый в контексте Angular для хранения глобального состояния приложения или в качестве поставщика данных.
Angular сервисы могут быть определены на уровне приложения, модуля или компонента.

Пример
```ts
import { Injectable } from '@angular/core';
import { HttpClient } from "@angular/common/http";

@Injectable({ providedIn: 'root' })
export class AccountsHttpService {
  constructor(private http: HttpClient) {}

  getUsers(): Observable {
    return this.http.get('/api/users')
  }
}

```

### Модули (Modules)

Angular модуль - это класс с декоратором <code>@NgModule()</code>, который служит изолирующей логической объединяющей структурой для компонентов, директив, фильтров и сервисов. Все перечисленные сущности определяются и конфигурируются с помощью <code>@NgModule()</code>.

Angular приложение имеет модульную архитектуру и состоит, по крайней мере, из одного главного, или корневого, модуля. Все остальные относятся к второстепенным.

Сама библиотека @angular также модульная:

- BrowserModule;
- CommonModule;
- FormsModule;
- ReactiveFormsModule;
- HttpClientModule;
- RouterModule и др.

Ключевая роль при создании Angular модуля у декоратора <code>@NgModule()</code>, принимающего конфигурационный объект со свойствами:

- imports - массив, где указывается список импортируемых второстепенных модулей;</br>
- exports - массив компонентов, директив и фильтров, которыми пользуются другие модули, если они импортируют текущий;</br>
- declarations - массив компонентов, директив и фильтров;</br>
- entryComponents - массив создаваемых динамически компонентов;</br>
- bootstrap - массив, в котором указывается компонент для загрузки;</br>
- providers - массив сервисов.</br>

По назначению модули можно классифицировать следующим образом:

- корневой;
- функциональный;
- маршрутизации;
- для поставки сервисов.
Корневой модуль - главный в приложении. Именно он загружается первым и импортирует в себя все второстепенные модули, которые могут импортировать в себя другие второстепенные модули.

Только корневой модуль может определять свойство <code>bootstrap</code> и импортировать <code>BrowserModule</code>.

```ts
@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    //
  ],
  bootstrap: [AppComponent],
})
export class AppModule {}
```

## 5. MVC, MVP, MVVM
## 6. Принципы SOLID, KISS, DRY, YAGNI
### 7. SOLID - это принципы разработки программного обеспечения, следуя которым Вы получите хороший код, который в дальнейшем будет хорошо масштабироваться и поддерживаться в рабочем состоянии.

<strong>S</strong> - Single Responsibility Principle - принцип единственной ответственности. Каждый класс должен иметь только одну зону ответственности.

<strong>O</strong> - Open closed Principle - принцип открытости-закрытости. Классы должны быть открыты для расширения, но закрыты для изменения.

<strong>L</strong> - Liskov substitution Principle - принцип подстановки Барбары Лисков. Должна быть возможность вместо базового (родительского) типа (класса) подставить любой его подтип (класс-наследник), при этом работа программы не должна измениться.

<strong>I</strong> -  Interface Segregation Principle - принцип разделения интерфейсов. Данный принцип обозначает, что не нужно заставлять клиента (класс) реализовывать интерфейс, который не имеет к нему отношения.

<strong>D</strong> - Dependency Inversion Principle - принцип инверсии зависимостей. Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракции. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

### Keep - It Simple, Stupid / Будь проще

Принцип KISS утверждает, что большинство систем работают лучше всего, если они остаются простыми, а не усложняются. Поэтому в области проектирования простота должна быть одной из ключевых целей, и следует избегать ненужной сложности в вашем коде

### DRY - Don’t Repeat Yourself / Не повторяйтесь

Эта концепция была впервые сформулирована в книге Энди Ханта и Дэйва Томаса «Программист-прагматик: путь от подмастерья к мастеру».

Идея вращается вокруг единого источника правды (single source of truth — SSOT). Что это вообще такое?

В проектировании и теории информационных систем единый источник истины (SSOT) – это практика структурирования информационных моделей и схемы данных, которая подразумевает, что все фрагменты данных обрабатываются (или редактируются) только в одном месте… SSOT предоставляют достоверные, актуальные и пригодные к использованию данные.

Использование SSOT позволит создать более прочную и понятную кодовую базу.

Дублирование кода – пустая трата времени и ресурсов. Вам придется поддерживать одну и ту же логику и тестировать код сразу в двух местах, причем если вы измените код в одном месте, его нужно будет изменить и в другом.

В большинстве случаев дублирование кода происходит из-за незнания системы. Прежде чем что-либо писать, проявите прагматизм: осмотритесь. Возможно, эта функция где-то реализована. Возможно, эта бизнес-логика существует в другом месте. Повторное использование кода – всегда разумное решение.

## YAGNI - You Aren’t Gonna Need It / Вам это не понадобится

Этот принцип прост и очевиден, но ему далеко не все следуют. Если пишете код, то будьте уверены, что он вам понадобится. Не пишите код, если думаете, что он пригодится позже.

Этот принцип применим при рефакторинге. Если вы занимаетесь рефакторингом метода, класса или файла, не бойтесь удалять лишние методы. Даже если раньше они были полезны – теперь они не нужны.

Может наступить день, когда они снова понадобятся – тогда вы сможете воспользоваться git-репозиторием, чтобы воскресить их из мертвых.

## 8. Event Loop, async/await JavaScript ES7 (ES2016)
## 9. Основные методы массива в JavaScript
## 10. Что нового в JavaScipt ES8 (ES2017)
## 11. Что нового в JavaScript ES9 (ES2018)
## 12. Что нового в JavaScript ES10 (ES2019)
## 13. Что нового в JavaScript ES11 (ES2020)
## 14. Что нового в JavaScript ES12 (ES2021)
## 15. Что нового в JavaScript ES13 (ES2022)

Подробнее об ECMAScript 2022 (ES13): https://javascript.plainenglish.io/latest-es13-javascript-features-24cba45c93f7
